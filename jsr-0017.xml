<?xml version="1.0" encoding="UTF-8"?><?xml-stylesheet type="text/xsl" href="default.xsl"?><fr:tree toc="true" show-metadata="true" show-heading="true" root="false" numbered="true" expanded="true" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" xmlns:html="http://www.w3.org/1999/xhtml"><fr:frontmatter><fr:anchor>332</fr:anchor><fr:addr type="user">jsr-0017</fr:addr><fr:route>jsr-0017.html</fr:route><fr:title text="Simple but Powerful Pratt Parsing">Simple but Powerful Pratt Parsing</fr:title><fr:taxon>Translation</fr:taxon><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link type="local" title="Alex Kladov" href="matklad.html" addr="matklad">Alex Kladov</fr:link></fr:author><fr:contributor><fr:link type="local" title="Jinser Kafka" href="jinser.html" addr="jinser">Jinser Kafka</fr:link></fr:contributor></fr:authors><fr:meta name="original">https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html</fr:meta></fr:frontmatter><fr:mainmatter>
  
  <fr:blockquote><fr:strong>tips</fr:strong>: Click on the translation to expand and view the original text. 点击译文可展开查看原文。</fr:blockquote>
<fr:blockquote>Translated according to the version last updated on Apr 13, 2020.</fr:blockquote><fr:blockquote>根据2020年4月13日更新的版本翻译。</fr:blockquote>
  <fr:p><html:details class="block">
    <html:summary>
欢迎阅读我关于 Pratt 解析的文章——语法分析的 monad 教程。关于 Pratt 解析的文章数量如此之多，以至于还有一篇<fr:link type="external" href="https://www.oilshell.org/blog/2017/03/31.html">概览文章</fr:link> :)
</html:summary>
    <fr:pre>Welcome to my article about Pratt parsing — the monad tutorial of syntactic analysis. The number of Pratt parsing articles is so large that there exists a survey post :)</fr:pre>
  </html:details></fr:p>

  <fr:p><html:details class="block">
    <html:summary>
本文的目标：
</html:summary>
    <fr:pre>The goals of this particular article are:</fr:pre>
  </html:details></fr:p>

  <fr:p><html:details class="block">
    <html:summary>
<fr:li><fr:ul>提出一个问题：所谓的左递归问题被夸大了。</fr:ul>
  <fr:ul>抱怨 BNF（巴科斯-瑙尔范式）在表达中缀表达式方面的不足。</fr:ul>
  <fr:ul>提供对 Pratt 解析算法的描述和实现，坚持核心概念，没有引入类似 DSL 的抽象。</fr:ul>
  <fr:ul>希望让自己最后一次试图理解这个算法。我曾经<fr:link type="external" href="https://github.com/rust-analyzer/rust-analyzer/blob/c388130f5ffbcbe7d3131213a24d12d02f769b87/crates/ra_parser/src/grammar/expressions.rs#L280-L281">实现过</fr:link>一个生产级的 Pratt 解析器，但我现在不再能立即理解那段代码了 :-)</fr:ul></fr:li>
</html:summary>
    <fr:pre>Raising an issue that the so-called left-recursion problem is overstated.
Complaining about inadequacy of BNF for representing infix expressions.
Providing a description and implementation of Pratt parsing algorithm which sticks to the core and doesn’t introduce a DSL-y abstraction.
Understanding the algorithm myself for hopefully the last time. I’ve implemented a production-grade Pratt parser once, but I no longer immediately understand that code :-)</fr:pre>
  </html:details></fr:p>

  <fr:p><html:details class="block">
    <html:summary>
本文假设读者对解析技术有一定的了解，例如，不会在这里解释
  <html:ruby>
    上下文无关文法
    <html:rp>(</html:rp>
    <html:rt>context free grammar</html:rt>
    <html:rp>)</html:rp>
  </html:ruby>
是什么。
</html:summary>
    <fr:pre>This post assumes a fair bit of familiarity with parsing techniques, and, for example, does not explain what a context free grammar is.</fr:pre>
  </html:details></fr:p>
<fr:tree toc="true" show-metadata="false" show-heading="true" root="false" numbered="true" expanded="true" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" xmlns:html="http://www.w3.org/1999/xhtml"><fr:frontmatter><fr:anchor>313</fr:anchor><fr:addr type="machine">#262</fr:addr><fr:route>unstable-262.html</fr:route><fr:title text="介绍    Introduction ">介绍 
  <html:sub>Introduction</html:sub>
</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link type="local" title="Alex Kladov" href="matklad.html" addr="matklad">Alex Kladov</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p><html:details class="block">
    <html:summary>

  <html:ruby>
    解析
    <html:rp>(</html:rp>
    <html:rt>parsing</html:rt>
    <html:rp>)</html:rp>
  </html:ruby>
是编译器将一系列
  <html:ruby>
    标记
    <html:rp>(</html:rp>
    <html:rt>token</html:rt>
    <html:rp>)</html:rp>
  </html:ruby>
转换为树状表示的过程：
</html:summary>
    <fr:pre>Parsing is the process by which a compiler turns a sequence of tokens into a tree representation:</fr:pre>
  </html:details></fr:p>
<fr:pre>                            Add
                 Parser     / \
 &quot;1 + 2 * 3&quot;    -------&gt;   1  Mul
                              / \
                             2   3</fr:pre>
  <fr:p><html:details class="block">
    <html:summary>
有许多方法可以完成这个任务，这些方法大致可以归为以下两类：
</html:summary>
    <fr:pre>There are many approaches to this task, which roughly fall into one of the broad two categories:</fr:pre>
  </html:details></fr:p>

  <fr:p><html:details class="block">
    <html:summary>
<fr:li><fr:ul>使用 DSL 来指定语言的抽象文法</fr:ul>
  <fr:ul>手写解析器</fr:ul></fr:li>
</html:summary>
    <fr:pre>Using a DSL to specify an abstract grammar of the language
Hand-writing the parser</fr:pre>
  </html:details></fr:p>

  <fr:p><html:details class="block">
    <html:summary>
Pratt 解析是手写解析最常用的技术之一。
</html:summary>
    <fr:pre>Pratt parsing is one of the most frequently used techniques for hand-written parsing.</fr:pre>
  </html:details></fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree toc="true" show-metadata="false" show-heading="true" root="false" numbered="true" expanded="true" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" xmlns:html="http://www.w3.org/1999/xhtml"><fr:frontmatter><fr:anchor>315</fr:anchor><fr:addr type="machine">#263</fr:addr><fr:route>unstable-263.html</fr:route><fr:title text="BNF">BNF</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link type="local" title="Alex Kladov" href="matklad.html" addr="matklad">Alex Kladov</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p><html:details class="block">
    <html:summary>
语法分析理论的顶峰在于发现将线性结构解码为树状结构的上下文无关文法表示法（通常使用 BNF 具体语法）：
</html:summary>
    <fr:pre>The pinnacle of syntactic analysis theory is discovering the context free grammar notation (often using BNF concrete syntax) for decoding linear structures into trees:</fr:pre>
  </html:details></fr:p>
<fr:pre>Item ::=
    StructItem
  | EnumItem
  | ...

StructItem ::=
    'struct' Name '{' FieldList '}'

...</fr:pre>
  <fr:p><html:details class="block">
    <html:summary>
我记得我当时对这个想法非常着迷，特别是它与自然语言句子结构的相似之处。然而，当我们开始描述表达式时，我的乐观情绪很快就消失了。自然表达式文法确实可以让人们看出什么是表达式。
</html:summary>
    <fr:pre>I remember being fascinated by this idea, especially by parallels with natural language sentence structure. However, my optimism quickly waned once we got to describing expressions. The natural expression grammar indeed allows one to see what is an expression.</fr:pre>
  </html:details></fr:p>
<fr:pre>Expr ::=
    Expr '+' Expr
  | Expr '*' Expr
  | '(' Expr ')'
  | 'number'</fr:pre>
  <fr:p><html:details class="block">
    <html:summary>
虽然这种文法看起来很棒，但实际上它是模糊且不精确的，需要重新编写以适用于自动解析器生成。具体来说，我们需要指定操作符的
  <html:ruby>
    优先级
    <html:rp>(</html:rp>
    <html:rt>precedence</html:rt>
    <html:rp>)</html:rp>
  </html:ruby>
和
  <html:ruby>
    结合性
    <html:rp>(</html:rp>
    <html:rt>associativity</html:rt>
    <html:rp>)</html:rp>
  </html:ruby>
。修正后的文法如下：
</html:summary>
    <fr:pre>Although this grammar looks great, it is in fact ambiguous and imprecise, and needs to be rewritten to be amendable to automated parser generation. Specifically, we need to specify precedence and associativity of operators. The fixed grammar looks like this:</fr:pre>
  </html:details></fr:p>
<fr:pre>Expr ::=
    Factor
  | Expr '+' Factor

Factor ::=
    Atom
  | Factor '*' Atom

Atom ::=
    'number'
  | '(' Expr ')'</fr:pre>
  <fr:p><html:details class="block">
    <html:summary>
对我来说，在这种新的表述中，表达式的“形状”完全丢失了。此外，我在学习了三四门形式语言课程后，才能够可靠地自己创建这种文法。
</html:summary>
    <fr:pre>To me, the “shape” of expressions feels completely lost in this new formulation. Moreover, it took me three or four courses in formal languages before I was able to reliably create this grammar myself.</fr:pre>
  </html:details></fr:p>

  <fr:p><html:details class="block">
    <html:summary>
这就是我为什么喜欢 Pratt 解析⸺它是对递归下降解析算法的改进，使用了优先级和结合性的自然术语来解析表达式，而不是语法混淆技术。
</html:summary>
    <fr:pre>And that’s why I love Pratt parsing — it is an enhancement of recursive descent parsing algorithm, which uses the natural terminology of precedence and associativity for parsing expressions, instead of grammar obfuscation techniques.</fr:pre>
  </html:details></fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree toc="true" show-metadata="false" show-heading="true" root="false" numbered="true" expanded="true" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" xmlns:html="http://www.w3.org/1999/xhtml"><fr:frontmatter><fr:anchor>317</fr:anchor><fr:addr type="machine">#264</fr:addr><fr:route>unstable-264.html</fr:route><fr:title text="递归下降和左递归    Recursive descent and left-recursion ">递归下降和左递归 
  <html:sub>Recursive descent and left-recursion</html:sub>
</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link type="local" title="Alex Kladov" href="matklad.html" addr="matklad">Alex Kladov</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p><html:details class="block">
    <html:summary>
手写解析器的最简单技术是
  <html:ruby>
    递归下降
    <html:rp>(</html:rp>
    <html:rt>recursive descent</html:rt>
    <html:rp>)</html:rp>
  </html:ruby>
，它将文法建模为一组相互递归的函数。例如，上述文法片段可以写成这样：
</html:summary>
    <fr:pre>The simplest technique for hand-writing a parser is recursive descent, which models the grammar as a set of mutually recursive functions. For example, the above item grammar fragment can look like this:</fr:pre>
  </html:details></fr:p>

  <html:pre><html:code><html:span><html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">item</html:span><html:span style="color: #797593">(</html:span><html:span style="font-style: italic;color: #907aa9">p</html:span><html:span style="color: #797593">:</html:span> <html:span style="color: #797593">&amp;</html:span><html:span style="color: #286983">mut</html:span> <html:span style="color: #56949f">Parser</html:span><html:span style="color: #797593">)</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    <html:span style="color: #286983">match</html:span> p<html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">peek</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>        <html:span style="color: #56949f">STRUCT_KEYWORD</html:span> =&gt; <html:span style="color: #d7827e">struct_item</html:span><html:span style="color: #797593">(</html:span>p<html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>        <html:span style="color: #56949f">ENUM_KEYWORD</html:span>   =&gt; <html:span style="color: #d7827e">enum_item</html:span><html:span style="color: #797593">(</html:span>p<html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>        ..<html:span style="color: #797593">.</html:span></html:span>
<html:span>    <html:span style="color: #797593">}</html:span></html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span>
<html:span />
<html:span><html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">struct_item</html:span><html:span style="color: #797593">(</html:span><html:span style="font-style: italic;color: #907aa9">p</html:span><html:span style="color: #797593">:</html:span> <html:span style="color: #797593">&amp;</html:span><html:span style="color: #286983">mut</html:span> <html:span style="color: #56949f">Parser</html:span><html:span style="color: #797593">)</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    p<html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">expect</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #56949f">STRUCT_KEYWORD</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span>    <html:span style="color: #d7827e">name</html:span><html:span style="color: #797593">(</html:span>p<html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span>    p<html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">expect</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #56949f">L_CURLY</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span>    <html:span style="color: #d7827e">field_list</html:span><html:span style="color: #797593">(</html:span>p<html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span>    p<html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">expect</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #56949f">R_CURLY</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span>
<html:span />
<html:span>..<html:span style="color: #797593">.</html:span></html:span></html:code></html:pre>

  <fr:p><html:details class="block">
    <html:summary>
传统上，教科书指出左递归文法是这种方法的
  <html:ruby>
    阿喀琉斯之踵
    <html:rp>(</html:rp>
    <html:rt>Achilles heel</html:rt>
    <html:rp>)</html:rp>
  </html:ruby>
，并利用这一缺点来促使产生更高级的 LR 解析技术。一种有问题的文法示例如下：
</html:summary>
    <fr:pre>Traditionally, text-books point out left-recursive grammars as the Achilles heel of this approach, and use this drawback to motivate more advanced LR parsing techniques. An example of problematic grammar can look like this:</fr:pre>
  </html:details></fr:p>
<fr:pre>Sum ::=
    Sum '+' Int
  | Int</fr:pre>
  <fr:p><html:details class="block">
    <html:summary>
确实，如果我们朴素地编码 <fr:code>sum</fr:code> 函数，这不会太有用：
</html:summary>
    <fr:pre>Indeed, if we naively code the sum function, it wouldn’t be too useful:</fr:pre>
  </html:details></fr:p>

  <html:pre><html:code><html:span><html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">sum</html:span><html:span style="color: #797593">(</html:span><html:span style="font-style: italic;color: #907aa9">p</html:span><html:span style="color: #797593">:</html:span> <html:span style="color: #797593">&amp;</html:span><html:span style="color: #286983">mut</html:span> <html:span style="color: #56949f">Parser</html:span><html:span style="color: #797593">)</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    <html:span style="font-style: italic;color: #797593">// Try first alternative</html:span></html:span>
<html:span>    <html:span style="color: #d7827e">sum</html:span><html:span style="color: #797593">(</html:span>p<html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span> <html:span style="font-style: italic;color: #797593">// (1)</html:span></html:span>
<html:span>    p<html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">expect</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #56949f">PLUS</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span>    <html:span style="color: #d7827e">int</html:span><html:span style="color: #797593">(</html:span>p<html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span />
<html:span>    <html:span style="font-style: italic;color: #797593">// If that fails, try the second one</html:span></html:span>
<html:span>    ..<html:span style="color: #797593">.</html:span><html:span style="font-style: italic;color: #56949f" /></html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span></html:code></html:pre>

  <fr:p><html:details class="block">
    <html:summary>
<fr:ol><fr:li>到这里，我们会立即进入循环并导致堆栈溢出</fr:li></fr:ol>
</html:summary>
    <fr:pre>(1): At this point we immediately loop and overflow the stack</fr:pre>
  </html:details></fr:p>

  <fr:p><html:details class="block">
    <html:summary>
理论上讲，解决这个问题需要重写语法以消除左递归。然而在实际操作中，对于手写解析器，解决方案要简单得多⸺打破纯递归范式，使用循环：
</html:summary>
    <fr:pre>A theoretical fix to the problem involves rewriting the grammar to eliminate the left recursion. However in practice, for a hand-written parser, a solution is much simpler — breaking away with a pure recursive paradigm and using a loop:</fr:pre>
  </html:details></fr:p>

  <html:pre><html:code><html:span><html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">sum</html:span><html:span style="color: #797593">(</html:span><html:span style="font-style: italic;color: #907aa9">p</html:span><html:span style="color: #797593">:</html:span> <html:span style="color: #797593">&amp;</html:span><html:span style="color: #286983">mut</html:span> <html:span style="color: #56949f">Parser</html:span><html:span style="color: #797593">)</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    <html:span style="color: #d7827e">int</html:span><html:span style="color: #797593">(</html:span>p<html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span>    <html:span style="color: #286983">while</html:span> p<html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">eat</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #56949f">PLUS</html:span><html:span style="color: #797593">)</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>        <html:span style="color: #d7827e">int</html:span><html:span style="color: #797593">(</html:span>p<html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span>    <html:span style="color: #797593">}</html:span></html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span></html:code></html:pre>
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree toc="true" show-metadata="false" show-heading="true" root="false" numbered="true" expanded="true" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" xmlns:html="http://www.w3.org/1999/xhtml"><fr:frontmatter><fr:anchor>319</fr:anchor><fr:addr type="machine">#265</fr:addr><fr:route>unstable-265.html</fr:route><fr:title text="Pratt 解析，一般“形状”    Pratt parsing, the general shape ">Pratt 解析，一般“形状” 
  <html:sub>Pratt parsing, the general shape</html:sub>
</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link type="local" title="Alex Kladov" href="matklad.html" addr="matklad">Alex Kladov</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p><html:details class="block">
    <html:summary>
仅使用循环不足以解析中缀表达式。相反，Pratt 解析同时使用循环和递归：
</html:summary>
    <fr:pre>Using just loops won’t be enough for parsing infix expressions. Instead, Pratt parsing uses both loops and recursion:</fr:pre>
  </html:details></fr:p>

  <html:pre><html:code><html:span><html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">parse_expr</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    ..<html:span style="color: #797593">.</html:span></html:span>
<html:span>    <html:span style="font-style: italic;color: #56949f">loop</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>        ...</html:span>
<html:span>        <html:span style="color: #d7827e">parse_expr</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span></html:span>
<html:span>        ...</html:span>
<html:span>    <html:span style="color: #797593">}</html:span></html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span></html:code></html:pre>

  <fr:p><html:details class="block">
    <html:summary>
它不仅会让你陷入
  <html:ruby>
    摩比乌斯
    <html:rp>(</html:rp>
    <html:rt>Möbeus</html:rt>
    <html:rp>)</html:rp>
  </html:ruby>
形状的仓鼠轮中，而且还能处理结合性和优先级问题！
</html:summary>
    <fr:pre>Not only does it send your mind into Möbeus-shaped hamster wheel, it also handles associativity and precedence!</fr:pre>
  </html:details></fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree toc="true" show-metadata="false" show-heading="true" root="false" numbered="true" expanded="true" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" xmlns:html="http://www.w3.org/1999/xhtml"><fr:frontmatter><fr:anchor>321</fr:anchor><fr:addr type="machine">#266</fr:addr><fr:route>unstable-266.html</fr:route><fr:title text="从优先级到绑定力    From Precedence to Binding Power ">从优先级到绑定力 
  <html:sub>From Precedence to Binding Power</html:sub>
</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link type="local" title="Alex Kladov" href="matklad.html" addr="matklad">Alex Kladov</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p><html:details class="block">
    <html:summary>
我要坦白：我总是被“高优先级”和“低优先级”弄糊涂。在 <fr:code>a + b * c</fr:code>，加法的优先级更低，但它在解析树的顶部…
</html:summary>
    <fr:pre>I have a confession to make: I am always confused by “high precedence” and “low precedence”. In a + b * c, addition has a lower precedence, but it is at the top of the parse tree…</fr:pre>
  </html:details></fr:p>

  <fr:p><html:details class="block">
    <html:summary>
因此，我发现用
  <html:ruby>
    绑定力
    <html:rp>(</html:rp>
    <html:rt>binding power</html:rt>
    <html:rp>)</html:rp>
  </html:ruby>
的概念来思考更直观。
</html:summary>
    <fr:pre>So instead, I find thinking in terms of binding power more intuitive.</fr:pre>
  </html:details></fr:p>
<fr:pre>expr:   A       +       B       *       C
power:      3       3       5       5</fr:pre>
  <fr:p><html:details class="block">
    <html:summary>
<fr:code>*</fr:code> 更强，它有更大的力将 <fr:code>B</fr:code> 和 <fr:code>C</fr:code> 结合在一起，于是这个表达式被解析为 <fr:code>A + (B * C)</fr:code>
</html:summary>
    <fr:pre>The * is stronger, it has more power to hold together B and C, and so the expression is parsed as A + (B * C).</fr:pre>
  </html:details></fr:p>

  <fr:p><html:details class="block">
    <html:summary>
但是结合性呢？在 <fr:code>A + B + C</fr:code> 中，所有操作符似乎都有相同的力，目前尚不清楚哪一个 <fr:code>+</fr:code> 要先结合在一起。不过这也可以用绑定力来建模，如果我们让它稍微不对称：
</html:summary>
    <fr:pre>What about associativity though? In A + B + C all operators seem to have the same power, and it is unclear which + to fold first. But this can also be modelled with power, if we make it slightly asymmetric:</fr:pre>
  </html:details></fr:p>
<fr:pre>expr:      A       +       B       +       C
power:  0      3      3.1      3      3.1     0</fr:pre>
  <fr:p><html:details class="block">
    <html:summary>
这里我们稍微提高了 <fr:code>+</fr:code> 的右绑定力，这样它能更紧密地和右操作数结合。我们还在两端添加了零，因为两边没有操作符可以绑定。在这种情况下，（只有）第一个 <fr:code>+</fr:code> 比它的邻居更强，将两边的参数结合在了一起，因此我们将它可以简化为：
</html:summary>
    <fr:pre>Here, we pumped the right power of + just a little bit, so that it holds the right operand tighter. We also added zeros at both ends, as there are no operators to bind from the sides. Here, the first (and only the first) + holds both of its arguments tighter than the neighbors, so we can reduce it:</fr:pre>
  </html:details></fr:p>
<fr:pre>expr:     (A + B)     +     C
power:  0          3    3.1    0</fr:pre>
  <fr:p><html:details class="block">
    <html:summary>
现在我们可以将第二个加号折叠起来，得到 <fr:code>(A + B) + C</fr:code>。或者，从语法树的角度看来，第二个 <fr:code>+</fr:code> 实际上喜欢右操作数更胜于左操作数，所以它更急于与 <fr:code>C</fr:code> 结合。在此过程中，第一个 <fr:code>+</fr:code> 抓住了 <fr:code>A</fr:code> 和 <fr:code>B</fr:code>，因为它们没有竞争对手。
</html:summary>
    <fr:pre>Now we can fold the second plus and get (A + B) + C. Or, in terms of the syntax tree, the second + really likes its right operand more than the left one, so it rushes to get hold of C. While he does that, the first + captures both A and B, as they are uncontested.</fr:pre>
  </html:details></fr:p>

  <fr:p><html:details class="block">
    <html:summary>
Pratt 解析的作用是通过从左到右处理字符串，找到这些比邻居操作符更强势的操作符。我们几乎已经到了可以开始编写代码的地步，但让我们先看看另一个示例。我们将使用函数组合操作符 <fr:code>.</fr:code>（
  <html:ruby>
    点
    <html:rp>(</html:rp>
    <html:rt>dot</html:rt>
    <html:rp>)</html:rp>
  </html:ruby>
）作为一个具有高绑定力的<fr:em>右</fr:em>结合操作符。也就是说，<fr:code>f . g . h</fr:code> 将被解析为 <fr:code>f . (g . h)</fr:code>，或者用绑定力来解释：
</html:summary>
    <fr:pre>What Pratt parsing does is that it finds these badass, stronger than neighbors operators, by processing the string left to right. We are almost at a point where we finally start writing some code, but let’s first look at the other running example. We will use function composition operator, . (dot) as a right associative operator with a high binding power. That is, f . g . h is parsed as f . (g . h), or, in terms of power</fr:pre>
  </html:details></fr:p>
<fr:pre>f     .    g     .    h
0   8.5    8   8.5    8   0</fr:pre></fr:mainmatter><fr:backmatter /></fr:tree><fr:tree toc="true" show-metadata="false" show-heading="true" root="false" numbered="true" expanded="true" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" xmlns:html="http://www.w3.org/1999/xhtml"><fr:frontmatter><fr:anchor>323</fr:anchor><fr:addr type="machine">#267</fr:addr><fr:route>unstable-267.html</fr:route><fr:title text="迷你 Pratt 解析器    Minimal Pratt Parser ">迷你 Pratt 解析器 
  <html:sub>Minimal Pratt Parser</html:sub>
</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link type="local" title="Alex Kladov" href="matklad.html" addr="matklad">Alex Kladov</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p><html:details class="block">
    <html:summary>
我们将解析一个基本原子为<fr:em>单字符</fr:em>数字和变量，操作符为标点的表达式。我们定义一个简单的
  <html:ruby>
    分词器
    <html:rp>(</html:rp>
    <html:rt>tokenizer</html:rt>
    <html:rp>)</html:rp>
  </html:ruby>
：
</html:summary>
    <fr:pre>We will be parsing expressions where basic atoms are single character numbers and variables, and which uses punctuation for operators. Let’s define a simple tokenizer:</fr:pre>
  </html:details></fr:p>

  <html:pre><html:code><html:span><html:span style="color: #907aa9">#<html:span style="color: #797593">[</html:span>derive<html:span style="color: #797593">(</html:span><html:span style="color: #56949f">Debug</html:span><html:span style="color: #797593">,</html:span> <html:span style="color: #56949f">Clone</html:span><html:span style="color: #797593">,</html:span> <html:span style="color: #56949f">Copy</html:span><html:span style="color: #797593">,</html:span> <html:span style="color: #56949f">PartialEq</html:span><html:span style="color: #797593">,</html:span> <html:span style="color: #56949f">Eq</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">]</html:span></html:span></html:span>
<html:span><html:span style="color: #286983">enum</html:span> <html:span style="color: #56949f">Token</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    <html:span style="color: #56949f">Atom</html:span><html:span style="color: #797593">(</html:span><html:span style="font-weight: bold;color: #56949f">char</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>    <html:span style="color: #56949f">Op</html:span><html:span style="color: #797593">(</html:span><html:span style="font-weight: bold;color: #56949f">char</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>    <html:span style="color: #56949f">Eof</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span>
<html:span />
<html:span><html:span style="color: #286983">struct</html:span> <html:span style="color: #56949f">Lexer</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    <html:span style="font-style: italic;color: #56949f">tokens</html:span><html:span style="color: #797593">:</html:span> <html:span style="color: #56949f">Vec</html:span><html:span style="color: #797593">&lt;</html:span><html:span style="color: #56949f">Token</html:span><html:span style="color: #797593">&gt;</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span>
<html:span />
<html:span><html:span style="color: #286983">impl</html:span> <html:span style="color: #56949f">Lexer</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    <html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">new</html:span><html:span style="color: #797593">(</html:span><html:span style="font-style: italic;color: #907aa9">input</html:span><html:span style="color: #797593">:</html:span> <html:span style="color: #797593">&amp;</html:span><html:span style="font-weight: bold;color: #56949f">str</html:span><html:span style="color: #797593">)</html:span> -&gt; <html:span style="color: #56949f">Lexer</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>        <html:span style="color: #286983">let</html:span> <html:span style="color: #286983">mut</html:span> tokens = input</html:span>
<html:span>            <html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">chars</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span></html:span>
<html:span>            <html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">filter</html:span><html:span style="color: #797593">(</html:span>|it| !it<html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">is_ascii_whitespace</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">)</html:span></html:span>
<html:span>            <html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">map</html:span><html:span style="color: #797593">(</html:span>|c| <html:span style="color: #286983">match</html:span> c <html:span style="color: #797593">{</html:span></html:span>
<html:span>                <html:span style="color: #ea9d34">'0'</html:span>..=<html:span style="color: #ea9d34">'9'</html:span> |</html:span>
<html:span>                <html:span style="color: #ea9d34">'a'</html:span>..=<html:span style="color: #ea9d34">'z'</html:span> | <html:span style="color: #ea9d34">'A'</html:span>..=<html:span style="color: #ea9d34">'Z'</html:span> =&gt; <html:span style="color: #56949f">Token</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #d7827e">Atom</html:span><html:span style="color: #797593">(</html:span>c<html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>                _ =&gt; <html:span style="color: #56949f">Token</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #d7827e">Op</html:span><html:span style="color: #797593">(</html:span>c<html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>            <html:span style="color: #797593">}</html:span><html:span style="color: #797593">)</html:span></html:span>
<html:span>            <html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">collect</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #797593">&lt;</html:span><html:span style="color: #56949f">Vec</html:span><html:span style="color: #797593">&lt;</html:span><html:span style="color: #56949f">_</html:span><html:span style="color: #797593">&gt;</html:span><html:span style="color: #797593">&gt;</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span>        tokens<html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">reverse</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span>        <html:span style="color: #56949f">Lexer</html:span> <html:span style="color: #797593">{</html:span> tokens <html:span style="color: #797593">}</html:span></html:span>
<html:span>    <html:span style="color: #797593">}</html:span></html:span>
<html:span />
<html:span>    <html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">next</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">&amp;</html:span><html:span style="color: #286983">mut</html:span> <html:span style="font-weight: bold;font-style: italic;color: #b4637a">self</html:span><html:span style="color: #797593">)</html:span> -&gt; <html:span style="color: #56949f">Token</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>        <html:span style="font-weight: bold;font-style: italic;color: #b4637a">self</html:span><html:span style="color: #797593">.</html:span><html:span style="font-style: italic;color: #56949f">tokens</html:span><html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">pop</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">unwrap_or</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #56949f">Token</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #56949f">Eof</html:span><html:span style="color: #797593">)</html:span></html:span>
<html:span>    <html:span style="color: #797593">}</html:span></html:span>
<html:span>    <html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">peek</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">&amp;</html:span><html:span style="color: #286983">mut</html:span> <html:span style="font-weight: bold;font-style: italic;color: #b4637a">self</html:span><html:span style="color: #797593">)</html:span> -&gt; <html:span style="color: #56949f">Token</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>        <html:span style="font-weight: bold;font-style: italic;color: #b4637a">self</html:span><html:span style="color: #797593">.</html:span><html:span style="font-style: italic;color: #56949f">tokens</html:span><html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">last</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">copied</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">unwrap_or</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #56949f">Token</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #56949f">Eof</html:span><html:span style="color: #797593">)</html:span></html:span>
<html:span>    <html:span style="color: #797593">}</html:span></html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span></html:code></html:pre>

  <fr:p><html:details class="block">
    <html:summary>
为了确保我们能正确地处理<html:del>优先级</html:del>绑定力，我们将把
  <html:ruby>
    中缀
    <html:rp>(</html:rp>
    <html:rt>infix</html:rt>
    <html:rp>)</html:rp>
  </html:ruby>
表达式转换为一种具有明确含义的标准符号⸺S-expressions（无论出于和种原因，在波兰不太流行）。
</html:summary>
    <fr:pre>To make sure that we got the precedence binding power correctly, we will be transforming infix expressions into a gold-standard (not so popular in Poland, for whatever reason) unambiguous notation — S-expressions:</fr:pre>
  </html:details></fr:p>
<fr:pre>1 + 2 * 3 == (+ 1 (* 2 3))</fr:pre>
  <html:pre><html:code><html:span><html:span style="color: #286983">use</html:span> std<html:span style="color: #797593">::</html:span>fmt<html:span style="color: #797593">;</html:span></html:span>
<html:span />
<html:span><html:span style="color: #286983">enum</html:span> <html:span style="color: #56949f">S</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    <html:span style="color: #56949f">Atom</html:span><html:span style="color: #797593">(</html:span><html:span style="font-weight: bold;color: #56949f">char</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>    <html:span style="color: #56949f">Cons</html:span><html:span style="color: #797593">(</html:span><html:span style="font-weight: bold;color: #56949f">char</html:span><html:span style="color: #797593">,</html:span> <html:span style="color: #56949f">Vec</html:span><html:span style="color: #797593">&lt;</html:span><html:span style="color: #56949f">S</html:span><html:span style="color: #797593">&gt;</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span>
<html:span />
<html:span><html:span style="color: #286983">impl</html:span> fmt<html:span style="color: #797593">::</html:span><html:span style="color: #56949f">Display</html:span> <html:span style="color: #286983">for</html:span> <html:span style="color: #56949f">S</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    <html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">fmt</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">&amp;</html:span><html:span style="font-weight: bold;font-style: italic;color: #b4637a">self</html:span><html:span style="color: #797593">,</html:span> <html:span style="font-style: italic;color: #907aa9">f</html:span><html:span style="color: #797593">:</html:span> <html:span style="color: #797593">&amp;</html:span><html:span style="color: #286983">mut</html:span> fmt<html:span style="color: #797593">::</html:span><html:span style="color: #56949f">Formatter</html:span><html:span style="color: #797593">&lt;</html:span><html:span style="color: #797593">'</html:span><html:span style="color: #56949f">_</html:span><html:span style="color: #797593">&gt;</html:span><html:span style="color: #797593">)</html:span> -&gt; fmt<html:span style="color: #797593">::</html:span><html:span style="color: #56949f">Result</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>        <html:span style="color: #286983">match</html:span> <html:span style="font-weight: bold;font-style: italic;color: #b4637a">self</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>            <html:span style="color: #56949f">S</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #56949f">Atom</html:span><html:span style="color: #797593">(</html:span>i<html:span style="color: #797593">)</html:span> =&gt; <html:span style="color: #d7827e">write</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span>f<html:span style="color: #797593">,</html:span> <html:span style="color: #ea9d34">&quot;{}&quot;</html:span><html:span style="color: #797593">,</html:span> i<html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>            <html:span style="color: #56949f">S</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #56949f">Cons</html:span><html:span style="color: #797593">(</html:span>head<html:span style="color: #797593">,</html:span> rest<html:span style="color: #797593">)</html:span> =&gt; <html:span style="color: #797593">{</html:span></html:span>
<html:span>                <html:span style="color: #d7827e">write</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span>f<html:span style="color: #797593">,</html:span> <html:span style="color: #ea9d34">&quot;({}&quot;</html:span><html:span style="color: #797593">,</html:span> head<html:span style="color: #797593">)</html:span>?<html:span style="color: #797593">;</html:span></html:span>
<html:span>                <html:span style="color: #286983">for</html:span> s <html:span style="color: #286983">in</html:span> rest <html:span style="color: #797593">{</html:span></html:span>
<html:span>                    <html:span style="color: #d7827e">write</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span>f<html:span style="color: #797593">,</html:span> <html:span style="color: #ea9d34">&quot; {}&quot;</html:span><html:span style="color: #797593">,</html:span> s<html:span style="color: #797593">)</html:span>?</html:span>
<html:span>                <html:span style="color: #797593">}</html:span></html:span>
<html:span>                <html:span style="color: #d7827e">write</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span>f<html:span style="color: #797593">,</html:span> <html:span style="color: #ea9d34">&quot;)&quot;</html:span><html:span style="color: #797593">)</html:span></html:span>
<html:span>            <html:span style="color: #797593">}</html:span></html:span>
<html:span>        <html:span style="color: #797593">}</html:span></html:span>
<html:span>    <html:span style="color: #797593">}</html:span></html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span></html:code></html:pre>

  <fr:p><html:details class="block">
    <html:summary>
接着让我们从这里开始：包括原子和两个二元操作符 <fr:code>+</fr:code> 和 <fr:code>*</fr:code> 的表达式：
</html:summary>
    <fr:pre>And let’s start with just this: expressions with atoms and two infix binary operators, + and *:</fr:pre>
  </html:details></fr:p>

  <html:pre><html:code><html:span><html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">expr</html:span><html:span style="color: #797593">(</html:span><html:span style="font-style: italic;color: #907aa9">input</html:span><html:span style="color: #797593">:</html:span> <html:span style="color: #797593">&amp;</html:span><html:span style="font-weight: bold;color: #56949f">str</html:span><html:span style="color: #797593">)</html:span> -&gt; <html:span style="color: #56949f">S</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    <html:span style="color: #286983">let</html:span> <html:span style="color: #286983">mut</html:span> lexer = <html:span style="color: #56949f">Lexer</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #d7827e">new</html:span><html:span style="color: #797593">(</html:span>input<html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span>    <html:span style="color: #d7827e">expr_bp</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">&amp;</html:span><html:span style="color: #286983">mut</html:span> lexer<html:span style="color: #797593">)</html:span></html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span>
<html:span />
<html:span><html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">expr_bp</html:span><html:span style="color: #797593">(</html:span><html:span style="font-style: italic;color: #907aa9">lexer</html:span><html:span style="color: #797593">:</html:span> <html:span style="color: #797593">&amp;</html:span><html:span style="color: #286983">mut</html:span> <html:span style="color: #56949f">Lexer</html:span><html:span style="color: #797593">)</html:span> -&gt; <html:span style="color: #56949f">S</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    <html:span style="color: #d7827e">todo</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span></html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span>
<html:span />
<html:span><html:span style="color: #907aa9">#<html:span style="color: #797593">[</html:span>test<html:span style="color: #797593">]</html:span></html:span></html:span>
<html:span><html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">tests</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    <html:span style="color: #286983">let</html:span> s = <html:span style="color: #d7827e">expr</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #ea9d34">&quot;1 + 2 * 3&quot;</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span>    <html:span style="color: #d7827e">assert_eq</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span>s<html:span style="color: #797593">.</html:span>to_string<html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span> <html:span style="color: #ea9d34">&quot;(+ 1 (* 2 3))&quot;</html:span><html:span style="color: #797593">)</html:span></html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span></html:code></html:pre>

  <fr:p><html:details class="block">
    <html:summary>
那么，通用方法大致是我们用来处理左递归的方法⸺从第一个数字开始解析，进入循环，消费操作符然后…做某事？
</html:summary>
    <fr:pre>So, the general approach is roughly the one we used to deal with left recursion — start with parsing a first number, and then loop, consuming operators and doing … something?</fr:pre>
  </html:details></fr:p>

  <html:pre><html:code><html:span><html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">expr_bp</html:span><html:span style="color: #797593">(</html:span><html:span style="font-style: italic;color: #907aa9">lexer</html:span><html:span style="color: #797593">:</html:span> <html:span style="color: #797593">&amp;</html:span><html:span style="color: #286983">mut</html:span> <html:span style="color: #56949f">Lexer</html:span><html:span style="color: #797593">)</html:span> -&gt; <html:span style="color: #56949f">S</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    <html:span style="color: #286983">let</html:span> lhs = <html:span style="color: #286983">match</html:span> lexer<html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">next</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>        <html:span style="color: #56949f">Token</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #56949f">Atom</html:span><html:span style="color: #797593">(</html:span>it<html:span style="color: #797593">)</html:span> =&gt; <html:span style="color: #56949f">S</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #d7827e">Atom</html:span><html:span style="color: #797593">(</html:span>it<html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>        t =&gt; <html:span style="color: #d7827e">panic</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #ea9d34">&quot;bad token: {:?}&quot;</html:span><html:span style="color: #797593">,</html:span> t<html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>    <html:span style="color: #797593">}</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span />
<html:span>    <html:span style="color: #286983">loop</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>        <html:span style="color: #286983">let</html:span> op = <html:span style="color: #286983">match</html:span> lexer<html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">next</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>            <html:span style="color: #56949f">Token</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #56949f">Eof</html:span> =&gt; <html:span style="color: #286983">break</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>            <html:span style="color: #56949f">Token</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #56949f">Op</html:span><html:span style="color: #797593">(</html:span>op<html:span style="color: #797593">)</html:span> =&gt; op<html:span style="color: #797593">,</html:span></html:span>
<html:span>            t =&gt; <html:span style="color: #d7827e">panic</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #ea9d34">&quot;bad token: {:?}&quot;</html:span><html:span style="color: #797593">,</html:span> t<html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>        <html:span style="color: #797593">}</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span />
<html:span>        <html:span style="color: #d7827e">todo</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span></html:span>
<html:span>    <html:span style="color: #797593">}</html:span></html:span>
<html:span />
<html:span>    lhs</html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span>
<html:span />
<html:span><html:span style="color: #907aa9">#<html:span style="color: #797593">[</html:span>test<html:span style="color: #797593">]</html:span></html:span></html:span>
<html:span><html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">tests</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    <html:span style="color: #286983">let</html:span> s = <html:span style="color: #d7827e">expr</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #ea9d34">&quot;1&quot;</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span> <html:span style="font-style: italic;color: #797593">// (1)</html:span></html:span>
<html:span>    <html:span style="color: #d7827e">assert_eq</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span>s<html:span style="color: #797593">.</html:span>to_string<html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span> <html:span style="color: #ea9d34">&quot;1&quot;</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span></html:code></html:pre>

  <fr:p><html:details class="block">
    <html:summary>
<fr:ol><fr:li>注意我们已经能够解析这个简单的测试表达式！</fr:li></fr:ol>
</html:summary>
    <fr:pre>(1) Note that we already can parse this simple test!</fr:pre>
  </html:details></fr:p>

  <fr:p><html:details class="block">
    <html:summary>
我们想使用绑定力的想法，因此让我们计算操作符左边和右边的力。我们用 <fr:code>u8</fr:code> 来表示绑定力，所以，为了满足结合性，我们会加 <fr:code>1</fr:code>，然后为输入的结尾保留 <fr:code>0</fr:code>，操作符的最低绑定力就是 <fr:code>1</fr:code> 了。
</html:summary>
    <fr:pre>We want to use this power idea, so let’s compute both left and right powers of the operator. We’ll use u8 to represent power, so, for associativity, we’ll add 1. And we’ll reserve the 0 power for the end of input, so the lowest power operator can have is 1.</fr:pre>
  </html:details></fr:p>

  <html:pre><html:code><html:span><html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">expr_bp</html:span><html:span style="color: #797593">(</html:span><html:span style="font-style: italic;color: #907aa9">lexer</html:span><html:span style="color: #797593">:</html:span> <html:span style="color: #797593">&amp;</html:span><html:span style="color: #286983">mut</html:span> <html:span style="color: #56949f">Lexer</html:span><html:span style="color: #797593">)</html:span> -&gt; <html:span style="color: #56949f">S</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    <html:span style="color: #286983">let</html:span> lhs = <html:span style="color: #286983">match</html:span> lexer<html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">next</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>        <html:span style="color: #56949f">Token</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #56949f">Atom</html:span><html:span style="color: #797593">(</html:span>it<html:span style="color: #797593">)</html:span> =&gt; <html:span style="color: #56949f">S</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #d7827e">Atom</html:span><html:span style="color: #797593">(</html:span>it<html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>        t =&gt; <html:span style="color: #d7827e">panic</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #ea9d34">&quot;bad token: {:?}&quot;</html:span><html:span style="color: #797593">,</html:span> t<html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>    <html:span style="color: #797593">}</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span />
<html:span>    <html:span style="color: #286983">loop</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>        <html:span style="color: #286983">let</html:span> op = <html:span style="color: #286983">match</html:span> lexer<html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">peek</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>            <html:span style="color: #56949f">Token</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #56949f">Eof</html:span> =&gt; <html:span style="color: #286983">break</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>            <html:span style="color: #56949f">Token</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #56949f">Op</html:span><html:span style="color: #797593">(</html:span>op<html:span style="color: #797593">)</html:span> =&gt; op<html:span style="color: #797593">,</html:span></html:span>
<html:span>            t =&gt; <html:span style="color: #d7827e">panic</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #ea9d34">&quot;bad token: {:?}&quot;</html:span><html:span style="color: #797593">,</html:span> t<html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>        <html:span style="color: #797593">}</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span>        <html:span style="color: #286983">let</html:span> <html:span style="color: #797593">(</html:span>l_bp<html:span style="color: #797593">,</html:span> r_bp<html:span style="color: #797593">)</html:span> = <html:span style="color: #d7827e">infix_binding_power</html:span><html:span style="color: #797593">(</html:span>op<html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span />
<html:span>        <html:span style="color: #d7827e">todo</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span></html:span>
<html:span>    <html:span style="color: #797593">}</html:span></html:span>
<html:span />
<html:span>    lhs</html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span>
<html:span />
<html:span><html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">infix_binding_power</html:span><html:span style="color: #797593">(</html:span><html:span style="font-style: italic;color: #907aa9">op</html:span><html:span style="color: #797593">:</html:span> <html:span style="font-weight: bold;color: #56949f">char</html:span><html:span style="color: #797593">)</html:span> -&gt; <html:span style="color: #797593">(</html:span><html:span style="font-weight: bold;color: #56949f">u8</html:span><html:span style="color: #797593">,</html:span> <html:span style="font-weight: bold;color: #56949f">u8</html:span><html:span style="color: #797593">)</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    <html:span style="color: #286983">match</html:span> op <html:span style="color: #797593">{</html:span></html:span>
<html:span>        <html:span style="color: #ea9d34">'+'</html:span> | <html:span style="color: #ea9d34">'-'</html:span> =&gt; <html:span style="color: #797593">(</html:span><html:span style="font-weight: bold;color: #2d8ea0">1</html:span><html:span style="color: #797593">,</html:span> <html:span style="font-weight: bold;color: #2d8ea0">2</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>        <html:span style="color: #ea9d34">'*'</html:span> | <html:span style="color: #ea9d34">'/'</html:span> =&gt; <html:span style="color: #797593">(</html:span><html:span style="font-weight: bold;color: #2d8ea0">3</html:span><html:span style="color: #797593">,</html:span> <html:span style="font-weight: bold;color: #2d8ea0">4</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>        _ =&gt; <html:span style="color: #d7827e">panic</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #ea9d34">&quot;bad op: {:?}&quot;</html:span><html:span style="color: #797593">,</html:span> op<html:span style="color: #797593">)</html:span></html:span>
<html:span>    <html:span style="color: #797593">}</html:span></html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span></html:code></html:pre>

  <fr:p><html:details class="block">
    <html:summary>
现在到了关键部分，我们将引入递归。考虑这个例子（绑定力在下）：
</html:summary>
    <fr:pre>And now comes the tricky bit, where we introduce recursion into the picture. Let’s think about this example (with powers below):</fr:pre>
  </html:details></fr:p>
<fr:pre>a   +   b   *   c   *   d   +   e
  1   2   3   4   3   4   1   2</fr:pre>
  <fr:p><html:details class="block">
    <html:summary>
光标现在位于第一个 <fr:code>+</fr:code> 号，我们知道左边的绑定力 <fr:code>bp</fr:code> 是 <fr:code>1</fr:code>，右边的是 <fr:code>2</fr:code>。左操作数 <fr:code>lhs</fr:code> 存储 <fr:code>a</fr:code>。<fr:code>+</fr:code> 之后的下一个操作符是 <fr:code>*</fr:code>，所以我们不应该将 <fr:code>b</fr:code> 添加到 <fr:code>a</fr:code> 中。问题在于我们还没有看到下一个操作符，我们刚刚经过 <fr:code>+</fr:code>。我们能加入
  <html:ruby>
    前瞻
    <html:rp>(</html:rp>
    <html:rt>lookahead</html:rt>
    <html:rp>)</html:rp>
  </html:ruby>
吗？看来不行⸺我们需要跳过 <fr:code>b</fr:code>、<fr:code>c</fr:code> 和 <fr:code>d</fr:code> 找到下一个具有更低绑定力的操作符，这听起来相当
  <html:ruby>
    无界
    <html:rp>(</html:rp>
    <html:rt>unbounded</html:rt>
    <html:rp>)</html:rp>
  </html:ruby>
。不过我们在逐步接近了！当前的右优先级是 <fr:code>2</fr:code>，为了能够折叠表达式，我们需要找到下一个优先级更低的操作符。因此，让我们从 <fr:code>b</fr:code> 开始递归调用 <fr:code>expr_bp</fr:code>，但也让它一旦遇到绑定优先级低于 <fr:code>2</fr:code> 的就停下。这就需要在主函数中增加 <fr:code>min_bp</fr:code> 参数。
</html:summary>
    <fr:pre>The cursor is at the first +, we know that the left bp is 1 and the right one is 2. The lhs stores a. The next operator after + is *, so we shouldn’t add b to a. The problem is that we haven’t yet seen the next operator, we are just past +. Can we add a lookahead? Looks like no — we’d have to look past all of b, c and d to find the next operator with lower binding power, which sounds pretty unbounded. But we are onto something! Our current right priority is 2, and, to be able to fold the expression, we need to find the next operator with lower priority. So let’s recursively call expr_bp starting at b, but also tell it to stop as soon as bp drops below 2. This necessitates the addition of min_bp argument to the main function.</fr:pre>
  </html:details></fr:p>

  <fr:p><html:details class="block">
    <html:summary>
于是，我们有了一个功能齐全的迷你 Pratt 解析器：
</html:summary>
    <fr:pre>And lo, we have a fully functioning minimal Pratt parser:</fr:pre>
  </html:details></fr:p>

  <html:pre><html:code><html:span><html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">expr</html:span><html:span style="color: #797593">(</html:span><html:span style="font-style: italic;color: #907aa9">input</html:span><html:span style="color: #797593">:</html:span> <html:span style="color: #797593">&amp;</html:span><html:span style="font-weight: bold;color: #56949f">str</html:span><html:span style="color: #797593">)</html:span> -&gt; <html:span style="color: #56949f">S</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    <html:span style="color: #286983">let</html:span> <html:span style="color: #286983">mut</html:span> lexer = <html:span style="color: #56949f">Lexer</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #d7827e">new</html:span><html:span style="color: #797593">(</html:span>input<html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span>    <html:span style="color: #d7827e">expr_bp</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">&amp;</html:span><html:span style="color: #286983">mut</html:span> lexer<html:span style="color: #797593">,</html:span> <html:span style="font-weight: bold;color: #2d8ea0">0</html:span><html:span style="color: #797593">)</html:span> <html:span style="font-style: italic;color: #797593">// (5)</html:span></html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span>
<html:span />
<html:span><html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">expr_bp</html:span><html:span style="color: #797593">(</html:span><html:span style="font-style: italic;color: #907aa9">lexer</html:span><html:span style="color: #797593">:</html:span> <html:span style="color: #797593">&amp;</html:span><html:span style="color: #286983">mut</html:span> <html:span style="color: #56949f">Lexer</html:span><html:span style="color: #797593">,</html:span> <html:span style="font-style: italic;color: #907aa9">min_bp</html:span><html:span style="color: #797593">:</html:span> <html:span style="font-weight: bold;color: #56949f">u8</html:span><html:span style="color: #797593">)</html:span> -&gt; <html:span style="color: #56949f">S</html:span> <html:span style="color: #797593">{</html:span> <html:span style="font-style: italic;color: #797593">// (1)</html:span></html:span>
<html:span>    <html:span style="color: #286983">let</html:span> <html:span style="color: #286983">mut</html:span> lhs = <html:span style="color: #286983">match</html:span> lexer<html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">next</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>        <html:span style="color: #56949f">Token</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #56949f">Atom</html:span><html:span style="color: #797593">(</html:span>it<html:span style="color: #797593">)</html:span> =&gt; <html:span style="color: #56949f">S</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #d7827e">Atom</html:span><html:span style="color: #797593">(</html:span>it<html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>        t =&gt; <html:span style="color: #d7827e">panic</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #ea9d34">&quot;bad token: {:?}&quot;</html:span><html:span style="color: #797593">,</html:span> t<html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>    <html:span style="color: #797593">}</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span />
<html:span>    <html:span style="color: #286983">loop</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>        <html:span style="color: #286983">let</html:span> op = <html:span style="color: #286983">match</html:span> lexer<html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">peek</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>            <html:span style="color: #56949f">Token</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #56949f">Eof</html:span> =&gt; <html:span style="color: #286983">break</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>            <html:span style="color: #56949f">Token</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #56949f">Op</html:span><html:span style="color: #797593">(</html:span>op<html:span style="color: #797593">)</html:span> =&gt; op<html:span style="color: #797593">,</html:span></html:span>
<html:span>            t =&gt; <html:span style="color: #d7827e">panic</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #ea9d34">&quot;bad token: {:?}&quot;</html:span><html:span style="color: #797593">,</html:span> t<html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>        <html:span style="color: #797593">}</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span />
<html:span>        <html:span style="color: #286983">let</html:span> <html:span style="color: #797593">(</html:span>l_bp<html:span style="color: #797593">,</html:span> r_bp<html:span style="color: #797593">)</html:span> = <html:span style="color: #d7827e">infix_binding_power</html:span><html:span style="color: #797593">(</html:span>op<html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span>        <html:span style="color: #286983">if</html:span> l_bp &lt; min_bp <html:span style="color: #797593">{</html:span> <html:span style="font-style: italic;color: #797593">// (2)</html:span></html:span>
<html:span>            <html:span style="color: #286983">break</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span>        <html:span style="color: #797593">}</html:span></html:span>
<html:span />
<html:span>        lexer<html:span style="color: #797593">.</html:span><html:span style="color: #d7827e">next</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span> <html:span style="font-style: italic;color: #797593">// (3)</html:span></html:span>
<html:span>        <html:span style="color: #286983">let</html:span> rhs = <html:span style="color: #d7827e">expr_bp</html:span><html:span style="color: #797593">(</html:span>lexer<html:span style="color: #797593">,</html:span> r_bp<html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span />
<html:span>        lhs = <html:span style="color: #56949f">S</html:span><html:span style="color: #797593">::</html:span><html:span style="color: #d7827e">Cons</html:span><html:span style="color: #797593">(</html:span>op<html:span style="color: #797593">,</html:span> <html:span style="color: #d7827e">vec</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">[</html:span>lhs<html:span style="color: #797593">,</html:span> rhs<html:span style="color: #797593">]</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span> <html:span style="font-style: italic;color: #797593">// (4)</html:span></html:span>
<html:span>    <html:span style="color: #797593">}</html:span></html:span>
<html:span />
<html:span>    lhs</html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span>
<html:span />
<html:span><html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">infix_binding_power</html:span><html:span style="color: #797593">(</html:span><html:span style="font-style: italic;color: #907aa9">op</html:span><html:span style="color: #797593">:</html:span> <html:span style="font-weight: bold;color: #56949f">char</html:span><html:span style="color: #797593">)</html:span> -&gt; <html:span style="color: #797593">(</html:span><html:span style="font-weight: bold;color: #56949f">u8</html:span><html:span style="color: #797593">,</html:span> <html:span style="font-weight: bold;color: #56949f">u8</html:span><html:span style="color: #797593">)</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    <html:span style="color: #286983">match</html:span> op <html:span style="color: #797593">{</html:span></html:span>
<html:span>        <html:span style="color: #ea9d34">'+'</html:span> | <html:span style="color: #ea9d34">'-'</html:span> =&gt; <html:span style="color: #797593">(</html:span><html:span style="font-weight: bold;color: #2d8ea0">1</html:span><html:span style="color: #797593">,</html:span> <html:span style="font-weight: bold;color: #2d8ea0">2</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>        <html:span style="color: #ea9d34">'*'</html:span> | <html:span style="color: #ea9d34">'/'</html:span> =&gt; <html:span style="color: #797593">(</html:span><html:span style="font-weight: bold;color: #2d8ea0">3</html:span><html:span style="color: #797593">,</html:span> <html:span style="font-weight: bold;color: #2d8ea0">4</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>        _ =&gt; <html:span style="color: #d7827e">panic</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #ea9d34">&quot;bad op: {:?}&quot;</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>    <html:span style="color: #797593">}</html:span></html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span>
<html:span />
<html:span><html:span style="color: #907aa9">#<html:span style="color: #797593">[</html:span>test<html:span style="color: #797593">]</html:span></html:span></html:span>
<html:span><html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">tests</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    <html:span style="color: #286983">let</html:span> s = <html:span style="color: #d7827e">expr</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #ea9d34">&quot;1&quot;</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span>    <html:span style="color: #d7827e">assert_eq</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span>s<html:span style="color: #797593">.</html:span>to_string<html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span> <html:span style="color: #ea9d34">&quot;1&quot;</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span />
<html:span>    <html:span style="color: #286983">let</html:span> s = <html:span style="color: #d7827e">expr</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #ea9d34">&quot;1 + 2 * 3&quot;</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span>    <html:span style="color: #d7827e">assert_eq</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span>s<html:span style="color: #797593">.</html:span>to_string<html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span> <html:span style="color: #ea9d34">&quot;(+ 1 (* 2 3))&quot;</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span />
<html:span>    <html:span style="color: #286983">let</html:span> s = <html:span style="color: #d7827e">expr</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #ea9d34">&quot;a + b * c * d + e&quot;</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span>    <html:span style="color: #d7827e">assert_eq</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span>s<html:span style="color: #797593">.</html:span>to_string<html:span style="color: #797593">(</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span> <html:span style="color: #ea9d34">&quot;(+ (+ a (* (* b c) d)) e)&quot;</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">;</html:span></html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span></html:code></html:pre>

  <fr:p><html:details class="block">
    <html:summary>
<fr:ol><fr:li><fr:code>min_bp</fr:code> 参数是关键的新增项。<fr:code>expr_bp</fr:code> 现在可以解析具有相对较高绑定力的表达式。一旦它遇到比 <fr:code>min_bp</fr:code> 更弱的绑定力时，就会停止解析。</fr:li>
  <fr:li>这就是 “停止解析” 的地方</fr:li>
  <fr:li>在这里，我们越过操作符本身并进行递归调用，注意我们如何使用 <fr:code>l_bp</fr:code> 与 <fr:code>min_bp</fr:code> 对比进行检查，并将 <fr:code>r_bp</fr:code> 作为递归调用的新 <fr:code>min_bp</fr:code>。因此你可以把 <fr:code>min_bp</fr:code> 看作当前表达式左侧操作符的绑定力。</fr:li>
  <fr:li>最后，在解析完正确的右侧表达式之后，我们组装出新的当前表达式。</fr:li>
  <fr:li>要开始递归，我们使用零作为绑定力。请记住，一开始左侧操作符的绑定优先级是可能的最低值，零，因为那里实际上没有操作符。</fr:li></fr:ol>
</html:summary>
    <fr:pre>(1) min_bp argument is the crucial addition. expr_bp now parses expressions with relatively high binding power. As soon as it sees something weaker than min_bp, it stops.
(2) This is the “it stops” point.
(3) And here we bump past the operator itself and make the recursive call. Note how we use l_bp to check against min_bp, and r_bp as the new min_bp of the recursive call. So, you can think about min_bp as the binding power of the operator to the left of the current expressions.
(4) Finally, after parsing the correct right hand side, we assemble the new current expression.
(5) To start the recursion, we use binding power of zero. Remember, at the beginning the binding power of the operator to the left is the lowest possible, zero, as there’s no actual operator there.</fr:pre>
  </html:details></fr:p>

  <fr:p><html:details class="block">
    <html:summary>
是的，这 40 行代码就是 Pratt 解析算法。它们有些难对付，但如果你理解了它们，其他部分就只是简单的扩展。
</html:summary>
    <fr:pre>So, yup, these 40 lines are the Pratt parsing algorithm. They are tricky, but, if you understand them, everything else is straightforward additions.</fr:pre>
  </html:details></fr:p>
</fr:mainmatter><fr:backmatter /></fr:tree><fr:tree toc="true" show-metadata="false" show-heading="true" root="false" numbered="true" expanded="true" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" xmlns:html="http://www.w3.org/1999/xhtml"><fr:frontmatter><fr:anchor>325</fr:anchor><fr:addr type="machine">#268</fr:addr><fr:route>unstable-268.html</fr:route><fr:title text="铃铛和哨子    Bells and Whistles ">铃铛和哨子 
  <html:sub>Bells and Whistles</html:sub>
</fr:title><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>19</fr:day></fr:date><fr:authors><fr:author><fr:link type="local" title="Alex Kladov" href="matklad.html" addr="matklad">Alex Kladov</fr:link></fr:author></fr:authors></fr:frontmatter><fr:mainmatter>
  <fr:p><html:details class="block">
    <html:summary>
现在让我们添加各种奇特的表达式以展示这个算法的强大功能和灵活性。首先，添加一个高优先级，右结合的函数组合操作符 <fr:code>.</fr:code>：
</html:summary>
    <fr:pre>Now let’s add all kinds of weird expressions to show the power and flexibility of the algorithm. First, let’s add a high-priority, right associative function composition operator: .:</fr:pre>
  </html:details></fr:p>

  <html:pre><html:code><html:span><html:span style="color: #286983">fn</html:span> <html:span style="color: #d7827e">infix_binding_power</html:span><html:span style="color: #797593">(</html:span><html:span style="font-style: italic;color: #907aa9">op</html:span><html:span style="color: #797593">:</html:span> <html:span style="font-weight: bold;color: #56949f">char</html:span><html:span style="color: #797593">)</html:span> -&gt; <html:span style="color: #797593">(</html:span><html:span style="font-weight: bold;color: #56949f">u8</html:span><html:span style="color: #797593">,</html:span> <html:span style="font-weight: bold;color: #56949f">u8</html:span><html:span style="color: #797593">)</html:span> <html:span style="color: #797593">{</html:span></html:span>
<html:span>    <html:span style="color: #286983">match</html:span> op <html:span style="color: #797593">{</html:span></html:span>
<html:span>        <html:span style="color: #ea9d34">'+'</html:span> | <html:span style="color: #ea9d34">'-'</html:span> =&gt; <html:span style="color: #797593">(</html:span><html:span style="font-weight: bold;color: #2d8ea0">1</html:span><html:span style="color: #797593">,</html:span> <html:span style="font-weight: bold;color: #2d8ea0">2</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>        <html:span style="color: #ea9d34">'*'</html:span> | <html:span style="color: #ea9d34">'/'</html:span> =&gt; <html:span style="color: #797593">(</html:span><html:span style="font-weight: bold;color: #2d8ea0">3</html:span><html:span style="color: #797593">,</html:span> <html:span style="font-weight: bold;color: #2d8ea0">4</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span><i data-value="1" class="callout" /></html:span>
<html:span class="highlight-line">        <html:span style="color: #ea9d34">'.'</html:span> =&gt; <html:span style="color: #797593">(</html:span><html:span style="font-weight: bold;color: #2d8ea0">6</html:span><html:span style="color: #797593">,</html:span> <html:span style="font-weight: bold;color: #2d8ea0">5</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>        _ =&gt; <html:span style="color: #d7827e">panic</html:span><html:span style="color: #d7827e">!</html:span><html:span style="color: #797593">(</html:span><html:span style="color: #ea9d34">&quot;bad op: {:?}&quot;</html:span><html:span style="color: #797593">)</html:span><html:span style="color: #797593">,</html:span></html:span>
<html:span>    <html:span style="color: #797593">}</html:span></html:span>
<html:span><html:span style="color: #797593">}</html:span></html:span></html:code></html:pre>
</fr:mainmatter><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter><fr:tree toc="false" show-metadata="false" show-heading="true" root="false" numbered="false" expanded="true" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" xmlns:html="http://www.w3.org/1999/xhtml"><fr:frontmatter><fr:title text="Related">Related</fr:title><fr:authors /></fr:frontmatter><fr:mainmatter><fr:tree toc="true" show-metadata="true" show-heading="true" root="false" numbered="false" expanded="false" xmlns:fr="http://www.jonmsterling.com/jms-005P.xml" xmlns:html="http://www.w3.org/1999/xhtml"><fr:frontmatter><fr:anchor>335</fr:anchor><fr:addr type="user">matklad</fr:addr><fr:route>matklad.html</fr:route><fr:title text="Alex Kladov">Alex Kladov</fr:title><fr:taxon>Person</fr:taxon><fr:authors /><fr:meta name="external">https://matklad.github.io/about.html</fr:meta><fr:meta name="github">https://github.com/matklad</fr:meta></fr:frontmatter><fr:mainmatter /><fr:backmatter /></fr:tree></fr:mainmatter><fr:backmatter /></fr:tree></fr:backmatter></fr:tree>